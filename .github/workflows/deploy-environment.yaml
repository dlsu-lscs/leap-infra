---
name: Deploy Full Environment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      backend_image:
        description: 'Backend image tag (e.g., sha-abc123 or latest)'
        required: false
        default: 'latest'
      frontend_image:
        description: 'Frontend image tag (e.g., sha-xyz789 or latest)'
        required: false
        default: 'latest'
      run_migrations:
        description: 'Run database migrations'
        required: false
        default: false
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout infrastructure
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.32.2"

      - name: Set up Kustomize
        uses: imranismail/setup-kustomize@v2
        with:
          kustomize-version: "5.6.0"

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Set environment variables
        id: env
        run: |
          if [ "${{ github.event.inputs.environment }}" == "production" ]; then
            echo "name=production" >> $GITHUB_OUTPUT
            echo "prefix=" >> $GITHUB_OUTPUT
          else
            echo "name=staging" >> $GITHUB_OUTPUT
            echo "prefix=staging-" >> $GITHUB_OUTPUT
          fi
          echo "Environment: ${{ steps.env.outputs.name }}"
          echo "Prefix: ${{ steps.env.outputs.prefix }}"

      - name: Update backend image reference
        if: github.event.inputs.backend_image != ''
        run: |
          echo "Updating backend image reference for ${{ steps.env.outputs.name }} to ${{ github.event.inputs.backend_image }}"
          cd overlays/${{ steps.env.outputs.name }}/backend
          kustomize edit set image ghcr.io/dlsu-lscs/leap25-backend=ghcr.io/dlsu-lscs/leap25-backend:${{ github.event.inputs.backend_image }}
          cd ../../../

      - name: Update frontend image reference
        if: github.event.inputs.frontend_image != ''
        run: |
          echo "Updating frontend image reference for ${{ steps.env.outputs.name }} to ${{ github.event.inputs.frontend_image }}"
          cd overlays/${{ steps.env.outputs.name }}/frontend
          kustomize edit set image ghcr.io/dlsu-lscs/leap25-frontend=ghcr.io/dlsu-lscs/leap25-frontend:${{ github.event.inputs.frontend_image }}
          cd ../../../

      - name: Run migrations
        if: github.event.inputs.run_migrations == 'true'
        timeout-minutes: 5
        run: |
          set -e
          echo "Applying migrations for ${{ steps.env.outputs.name }} environment"

          # Create a temporary directory for the migration job
          mkdir -p temp-migrations

          # Copy the base migration job definition to the temp directory
          cp -r base/migrations/* temp-migrations/

          # Create a kustomization file that correctly references local resources
          cat <<EOF > temp-migrations/kustomization.yaml
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization
          resources:
          - job.yaml
          namePrefix: ${{ steps.env.outputs.prefix }}
          EOF

          # Update the image if specified
          if [ -n "${{ github.event.inputs.backend_image }}" ]; then
            cd temp-migrations
            kustomize edit set image ghcr.io/dlsu-lscs/leap25-backend=ghcr.io/dlsu-lscs/leap25-backend:${{ github.event.inputs.backend_image }}
            cd ..
          fi

          # Apply the migration job
          kubectl apply -k temp-migrations

          JOB_NAME="${{ steps.env.outputs.prefix }}leap25-db-migration"
          echo "Migration job name: $JOB_NAME"

          echo "Waiting for migration job completion..."
          kubectl wait --for=condition=complete job/$JOB_NAME --timeout=300s

          if [ $? -ne 0 ]; then
            echo "Migration job failed or timed out"
            kubectl logs job/$JOB_NAME
            exit 1
          fi

          echo "Migrations completed successfully"
          kubectl logs job/$JOB_NAME

          # Clean up temp directory
          rm -rf temp-migrations

      - name: Deploy full environment
        timeout-minutes: 10
        run: |
          echo "Deploying full environment to ${{ steps.env.outputs.name }}"

          # apply all components for the environment
          kubectl apply -k overlays/${{ steps.env.outputs.name }}

          echo "Waiting for backend deployment rollout..."
          kubectl rollout status deployment/${{ steps.env.outputs.prefix }}leap25-backend --timeout=300s

          echo "Waiting for frontend deployment rollout..."
          kubectl rollout status deployment/${{ steps.env.outputs.prefix }}leap25-frontend --timeout=300s

          echo "Checking HPA status..."
          kubectl get hpa

          echo "Environment deployment completed successfully"

      - name: Cleanup migration job
        if: always() && github.event.inputs.run_migrations == 'true'
        continue-on-error: true
        run: |
          echo "Cleaning up migration job..."
          kubectl delete job/${{ steps.env.outputs.prefix }}leap25-db-migration

      - name: Notify deployment success
        if: success()
        run: |
          echo "Environment deployment to ${{ steps.env.outputs.name }} completed successfully"
          echo "Backend image: ${{ github.event.inputs.backend_image || 'unchanged' }}"
          echo "Frontend image: ${{ github.event.inputs.frontend_image || 'unchanged' }}"
          echo "Migrations run: ${{ github.event.inputs.run_migrations }}"
          # add notification integration (Slack, Teams, etc.)

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "Environment deployment to ${{ steps.env.outputs.name }} failed"
          echo "Backend image: ${{ github.event.inputs.backend_image || 'unchanged' }}"
          echo "Frontend image: ${{ github.event.inputs.frontend_image || 'unchanged' }}"
          echo "Migrations run: ${{ github.event.inputs.run_migrations }}"
          # add notification integration (Slack, Teams, etc.)

      - name: Verify full environment health
        timeout-minutes: 5
        run: |
          echo "Verifying complete environment health..."

          # test pod for health checks
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Pod
          metadata:
            name: env-healthcheck
            namespace: default
            labels:
              app: env-healthcheck
          spec:
            containers:
            - name: curl
              image: curlimages/curl:7.88.1
              command: ["sleep", "600"]
            restartPolicy: Never
          EOF

          kubectl wait --for=condition=ready pod/env-healthcheck --timeout=60s

          # internal backend health check
          echo "Checking internal backend health..."
          BACKEND_INTERNAL_STATUS=$(kubectl exec deploy/${{ steps.env.outputs.prefix }}leap25-backend -- curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/health/live || echo "Failed")

          if [[ "$BACKEND_INTERNAL_STATUS" == "200" ]]; then
            echo "✅ Internal backend health check: PASSED"
          else
            echo "❌ Internal backend health check: FAILED with status $BACKEND_INTERNAL_STATUS"
            echo "Backend logs:"
            kubectl logs deploy/${{ steps.env.outputs.prefix }}leap25-backend --tail=20
          fi

          # internal frontend health check
          echo "Checking internal frontend health..."
          FRONTEND_INTERNAL_STATUS=$(kubectl exec env-healthcheck -- curl -s -o /dev/null -w "%{http_code}" http://${{ steps.env.outputs.prefix }}leap25-frontend.default.svc.cluster.local:80/ || echo "Failed")

          if [[ "$FRONTEND_INTERNAL_STATUS" =~ ^(200|301|302)$ ]]; then
            echo "✅ Internal frontend health check: PASSED with status $FRONTEND_INTERNAL_STATUS"
          else
            echo "❌ Internal frontend health check: FAILED with status $FRONTEND_INTERNAL_STATUS"
            kubectl exec env-healthcheck -- curl -v http://${{ steps.env.outputs.prefix }}leap25-frontend.default.svc.cluster.local:80/
          fi

          # external backend health check
          BACKEND_DOMAIN="${{ github.event.inputs.environment == 'production' && 'api.dlsucso-leap.com' || 'api-staging.dlsucso-leap.com' }}"
          echo "Checking external backend ingress at https://$BACKEND_DOMAIN/health/live..."

          BACKEND_EXTERNAL_STATUS=$(kubectl exec env-healthcheck -- curl -s -o /dev/null -w "%{http_code}" -k https://$BACKEND_DOMAIN/health/live --connect-timeout 10 || echo "Failed")

          if [[ "$BACKEND_EXTERNAL_STATUS" == "200" ]]; then
            echo "✅ External backend ingress check: PASSED"
          else
            echo "⚠️ External backend ingress check: NO RESPONSE or FAILED with status $BACKEND_EXTERNAL_STATUS"
            echo "This might be expected if DNS hasn't propagated yet or certificates aren't ready"
            kubectl get ingress | grep backend
            kubectl describe ingress ${{ steps.env.outputs.prefix }}leap25-backend-ingress
            kubectl get certificate | grep backend
          fi

          # external frontend health check
          FRONTEND_DOMAIN="${{ github.event.inputs.environment == 'production' && 'dlsucso-leap.com' || 'staging.dlsucso-leap.com' }}"
          echo "Checking external frontend ingress at https://$FRONTEND_DOMAIN..."

          FRONTEND_EXTERNAL_STATUS=$(kubectl exec env-healthcheck -- curl -s -o /dev/null -w "%{http_code}" -k https://$FRONTEND_DOMAIN/ --connect-timeout 10 || echo "Failed")

          if [[ "$FRONTEND_EXTERNAL_STATUS" =~ ^(200|301|302)$ ]]; then
            echo "✅ External frontend ingress check: PASSED with status $FRONTEND_EXTERNAL_STATUS"
          else
            echo "⚠️ External frontend ingress check: NO RESPONSE or FAILED with status $FRONTEND_EXTERNAL_STATUS"
            echo "This might be expected if DNS hasn't propagated yet or certificates aren't ready"
            kubectl get ingress | grep frontend
            kubectl describe ingress ${{ steps.env.outputs.prefix }}leap25-frontend-ingress
            kubectl get certificate | grep frontend
          fi

          # report overall status
          echo ""
          echo "HEALTH CHECK SUMMARY:"
          echo "====================="
          echo "Backend Internal Health: $BACKEND_INTERNAL_STATUS (Expected: 200)"
          echo "Frontend Internal Health: $FRONTEND_INTERNAL_STATUS (Expected: 200|301|302)"
          echo "Backend External Health: $BACKEND_EXTERNAL_STATUS (Expected: 200)"
          echo "Frontend External Health: $FRONTEND_EXTERNAL_STATUS (Expected: 200|301|302)"

          echo ""
          echo "RESOURCE STATUS:"
          echo "==============="
          echo "Deployments:"
          kubectl get deployments | grep leap25
          echo ""
          echo "Pods:"
          kubectl get pods | grep leap25
          echo ""
          echo "HPAs:"
          kubectl get hpa | grep leap25
          echo ""
          echo "Ingresses:"
          kubectl get ingress | grep leap25

          # clean up test pod
          kubectl delete pod env-healthcheck

          # only fail if internal checks failed
          if [[ "$BACKEND_INTERNAL_STATUS" != "200" ]] || [[ ! "$FRONTEND_INTERNAL_STATUS" =~ ^(200|301|302)$ ]]; then
            echo "❌ Environment deployment verification failed - internal service checks failed"
            exit 1
          fi
